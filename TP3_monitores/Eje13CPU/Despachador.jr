/* This JR file was generated by m2jr */
/* for the signal and wait signaling discipline */


// Despachador.m, line 1: _monitor Despachador {  //HOARE

class Despachador {
  sem m_mutex = 1;
  sem m_urgentq = 0;
  int m_n_urgentq = 0;
  String m_name;
  public Despachador(String n) {
    this.m_name = n;
  }
  private void m_next() {
      if (m_n_urgentq > 0) {
        m_n_urgentq--;
        V(m_urgentq);
      }
      else {
        V(m_mutex);
      }
  }

// Despachador.m, line 2: 


// Despachador.m, line 3:     _condvar cpu;


// Despachador.m, line 4: 


// Despachador.m, line 5:     _var int asignaciones0 = 0;

private m_condvar cpu = new m_condvar("cpu");
private int
asignaciones0
=0;
// Despachador.m, line 6:     _var int asignaciones1 = 0;

private int
asignaciones1
=0;
// Despachador.m, line 7:     _var boolean cpu0Libre = true;

private boolean
cpu0Libre
=true
;
// Despachador.m, line 8:     _var boolean cpu1Libre = true;

private boolean
cpu1Libre
=true
;
// Despachador.m, line 9: 


// Despachador.m, line 10:     _proc int adquirirCPU(int i){

public
int
adquirirCPU
(int
i
){
    op void m_return_from_wait();
    P(m_mutex);

// Despachador.m, line 11:         int proceso = i;

int
proceso
=i
;
// Despachador.m, line 12:         while(!cpu0Libre && !cpu1Libre){

while
(!cpu0Libre
&&!cpu1Libre
){
// Despachador.m, line 13:             _wait(cpu);

{  m_condvar m_cv = (cpu );
  send m_cv.m_wait(m_return_from_wait,0);
  send m_cv.m_wait_ranks(0);
  m_next();
  P(m_return_from_wait);
}
// Despachador.m, line 14:         }


// Despachador.m, line 15:         if(cpu0Libre){

}if
(cpu0Libre
){
// Despachador.m, line 16:             cpu0Libre = false;

cpu0Libre
=false
;
// Despachador.m, line 17:             asignaciones0++;        

asignaciones0
++;
// Despachador.m, line 18:             _return 0; // Retorna el identificador de la CPU adquirida

{ if (true) {
  m_next();
  return 
0
// Despachador.m, line 19:         }else if(cpu1Libre){

;
}}
}else
if
(cpu1Libre
){
// Despachador.m, line 20:             cpu1Libre = false;

cpu1Libre
=false
;
// Despachador.m, line 21:             asignaciones1++;

asignaciones1
++;
// Despachador.m, line 22:             _return 1;

{ if (true) {
  m_next();
  return 
1
// Despachador.m, line 23:         }

;
}}

// Despachador.m, line 24:     }

}
// Despachador.m, line 25: 


// Despachador.m, line 26:     _proc void liberarCPU(int cp, int proceso){

  m_next();
throw new RuntimeException("reached end of non-void _proc (Despachador.m, line 26) without executing a return");
}
public
void
liberarCPU
(int
cp
,int
proceso
){
    op void m_return_from_wait();
    P(m_mutex);

// Despachador.m, line 27:         if(cp == 0){

if
(cp
==0){
// Despachador.m, line 28:             cpu0Libre = true;     

cpu0Libre
=true
;
// Despachador.m, line 29:         }else if(cp == 1){

}else
if
(cp
==1){
// Despachador.m, line 30:             cpu1Libre = true;

cpu1Libre
=true
;
// Despachador.m, line 31:         }


// Despachador.m, line 32:         _signal(cpu);

}{ if ((cpu ).m_signal()) {
  P(m_mutex);
}}

// Despachador.m, line 33:     }


// Despachador.m, line 34: 


// Despachador.m, line 35: }

  m_next();
}

// Despachador.m, line 36: 


// Despachador.m, line 37: //Para compilar y hacer un Singal and Wait es de esta manera    m2jr -sw MonitorTest.m

}
