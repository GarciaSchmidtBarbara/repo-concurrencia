/* This JR file was generated by m2jr */
/* for the signal and wait signaling discipline */


// MonitorPizza.m, line 1: _monitor MonitorPizza {

class MonitorPizza {
  sem m_mutex = 1;
  sem m_urgentq = 0;
  int m_n_urgentq = 0;
  String m_name;
  public MonitorPizza(String n) {
    this.m_name = n;
  }
  private void m_next() {
      if (m_n_urgentq > 0) {
        m_n_urgentq--;
        V(m_urgentq);
      }
      else {
        V(m_mutex);
      }
  }

// MonitorPizza.m, line 2:    _condvar AgregarQueso;


// MonitorPizza.m, line 3:    _condvar AgregarSalsa;

private m_condvar AgregarQueso = new m_condvar("AgregarQueso");

// MonitorPizza.m, line 4:    _condvar AgregarMorron;

private m_condvar AgregarSalsa = new m_condvar("AgregarSalsa");

// MonitorPizza.m, line 5: 


// MonitorPizza.m, line 6:    _proc void EsperarQueso() {

private m_condvar AgregarMorron = new m_condvar("AgregarMorron");
public
void
EsperarQueso
(){
    op void m_return_from_wait();
    P(m_mutex);

// MonitorPizza.m, line 7:        _wait(AgregarQueso);

{  m_condvar m_cv = (AgregarQueso );
  send m_cv.m_wait(m_return_from_wait,0);
  send m_cv.m_wait_ranks(0);
  m_next();
  P(m_return_from_wait);
}
// MonitorPizza.m, line 8:    }


// MonitorPizza.m, line 9: 


// MonitorPizza.m, line 10:    _proc void EsperarSalsa() {

  m_next();
}
public
void
EsperarSalsa
(){
    op void m_return_from_wait();
    P(m_mutex);

// MonitorPizza.m, line 11:        _wait(AgregarSalsa);

{  m_condvar m_cv = (AgregarSalsa );
  send m_cv.m_wait(m_return_from_wait,0);
  send m_cv.m_wait_ranks(0);
  m_next();
  P(m_return_from_wait);
}
// MonitorPizza.m, line 12:    }


// MonitorPizza.m, line 13: 


// MonitorPizza.m, line 14:    _proc void EsperarMorron() {

  m_next();
}
public
void
EsperarMorron
(){
    op void m_return_from_wait();
    P(m_mutex);

// MonitorPizza.m, line 15:        _wait(AgregarMorron);

{  m_condvar m_cv = (AgregarMorron );
  send m_cv.m_wait(m_return_from_wait,0);
  send m_cv.m_wait_ranks(0);
  m_next();
  P(m_return_from_wait);
}
// MonitorPizza.m, line 16:    }


// MonitorPizza.m, line 17: 


// MonitorPizza.m, line 18:    _proc void ValidarIngredientes(char[] ingre, int size) {

  m_next();
}
public
void
ValidarIngredientes
(char
[]ingre
,int
size
){
    op void m_return_from_wait();
    P(m_mutex);

// MonitorPizza.m, line 19:        if (!contiene(ingre, size, 'Q')) {

if
(!contiene
(ingre
,size
,'Q')){
// MonitorPizza.m, line 20:            _signal(AgregarQueso);

{ if ((AgregarQueso ).m_signal()) {
  P(m_mutex);
}}

// MonitorPizza.m, line 21:        }


// MonitorPizza.m, line 22:        if (!contiene(ingre, size, 'S')) {

}if
(!contiene
(ingre
,size
,'S')){
// MonitorPizza.m, line 23:            _signal(AgregarSalsa);

{ if ((AgregarSalsa ).m_signal()) {
  P(m_mutex);
}}

// MonitorPizza.m, line 24:        }


// MonitorPizza.m, line 25:        if (!contiene(ingre, size, 'M')) {

}if
(!contiene
(ingre
,size
,'M')){
// MonitorPizza.m, line 26:            _signal(AgregarMorron);

{ if ((AgregarMorron ).m_signal()) {
  P(m_mutex);
}}

// MonitorPizza.m, line 27:        }


// MonitorPizza.m, line 28:    }

}
// MonitorPizza.m, line 29: 


// MonitorPizza.m, line 30:    _proc boolean contiene(char[] arr, int size, char c) {

  m_next();
}
public
boolean
contiene
(char
[]arr
,int
size
,char
c
){
    op void m_return_from_wait();
    P(m_mutex);

// MonitorPizza.m, line 31:        for (int i = 0; i < size; i++) {

for
(int
i
=0;i
<size
;i
++){
// MonitorPizza.m, line 32:            if (arr[i] == c) return true;

if
(arr
[i
]==c
){ if (true) {
  m_next();
  return 
true

// MonitorPizza.m, line 33:        }

;
}}

// MonitorPizza.m, line 34:        return false;

}{ if (true) {
  m_next();
  return 
false

// MonitorPizza.m, line 35:    }

;
}}

// MonitorPizza.m, line 36: }

  m_next();
throw new RuntimeException("reached end of non-void _proc (MonitorPizza.m, line 36) without executing a return");
}
}
